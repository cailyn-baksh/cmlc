package io.github.cailyn_baksh.cmlc;

import com.thaiopensource.relaxng.jaxp.CompactSyntaxSchemaFactory;
import io.github.cailyn_baksh.cmlc.cedarml.CedarMLType;
import io.github.cailyn_baksh.cmlc.cedarml.widgets.AttrSchema;
import io.github.cailyn_baksh.cmlc.cedarml.widgets.CMLWidgetSchema;
import io.github.cailyn_baksh.cmlc.cedarml.widgets.SetPropertySchema;
import io.github.cailyn_baksh.cmlc.utils.CodeWriter;
import io.github.cailyn_baksh.cmlc.utils.IdentifierGenerator;
import io.github.cailyn_baksh.cmlc.utils.Template;
import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.dom4j.Node;
import org.dom4j.io.SAXReader;
import org.xml.sax.SAXException;

import javax.xml.XMLConstants;
import javax.xml.transform.Source;
import javax.xml.transform.stream.StreamSource;
import javax.xml.validation.Schema;
import javax.xml.validation.SchemaFactory;
import javax.xml.validation.Validator;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathFactory;
import java.io.*;
import java.net.URISyntaxException;
import java.net.URL;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Parses CML files and generates the corresponding C code.
 */
public class CMLCompiler {
    /**
     * Thrown when an error occurs parsing CedarML
     */
    public class CMLParseException extends Exception {
        private String msg;

        public CMLParseException(String message) {
            msg = message;
        }

        @Override
        public String getMessage() {
            return msg;
        }
    }

    private static Logger logger = Logger.getLogger("io.github.cailyn_baksh.cmlc");

    /** URL to the RELAX NG Schema resource for CedarML */
    public static final URL CML_SCHEMA = CMLCompiler.class.getClassLoader().getResource("cedarml.rnc");
    /** URL to the built-in components of CedarML */
    public static final URL CML_BUILTIN = CMLCompiler.class.getClassLoader().getResource("builtin.cml");
    /** A comment prepended to each generated file to indicate which version generated the file */
    public static final String GENERATOR_COMMENT = """
            //
            // Generated by cmlc version %s
            //
            """.formatted(Main.CMLC_VERSION);

    /** The path to the source file */
    private String srcFile;
    /** The path to the output file */
    private String outDir;
    /** The base name of the output files */
    private String baseFileName;
    private XPath xpath = XPathFactory.newInstance().newXPath();

    private Document cmlDocument;
    /** The widgets defined in this document */
    private Map<String, CMLWidgetSchema> widgetSchemas = new HashMap<>();

    /**
     * Instantiate a new compiler
     * @param srcFile Path to the source file
     * @param outDir Path to place output files in
     * @param baseFileName The base name of the output file
     * @throws DocumentException If there is an error parsing the CML file into the DOM
     * @throws IOException If an error occurs while reading the file
     * @throws CMLParseException If there is an error in the syntax of the CML file
     */
    public CMLCompiler(String srcFile, String outDir, String baseFileName) throws DocumentException, IOException, CMLParseException {
        this.srcFile = srcFile;
        this.outDir = outDir;
        this.baseFileName = baseFileName;

        // Import builtins
        logger.fine("Importing builtins");
        try {
            Document builtin = loadXMLDocument(new File(CML_BUILTIN.toURI()));
            loadWidgets(builtin);
        } catch (URISyntaxException e) {
            // Shouldn't happen
            logger.fine("Error accessing resource " + CML_BUILTIN.toString());
            logger.log(Level.FINE, e.getMessage(), e);
            return;
        }

        // Load XML & validate document against schema
        logger.info("Loading " + srcFile);
        cmlDocument = loadXMLDocument(new File(srcFile));

        // Load widgets from document
        loadWidgets(cmlDocument);

        // Import widgets
        List<Node> importNodes = cmlDocument.selectNodes("/cedarml/import");
        for (Node importNode : importNodes) {
            // @path guaranteed by schema
            String path = importNode.valueOf("@path");
            logger.info("Importing file " + path);
            Document doc = loadXMLDocument(new File(path));
            loadWidgets(doc);
        }
    }

    /**
     * Validates a file against the CML schema and loads it into the DOM
     * @param file The file to load
     * @return A Document object representing the file. Can return null if the file at
     *         CML_SCHEMA is malformed.
     * @throws IOException If an error occurred while reading the file
     * @throws CMLParseException If there is an error in the syntax of the CML file
     * @throws DocumentException If there is an error parsing the CML file into the DOM
     */
    private Document loadXMLDocument(File file) throws IOException, CMLParseException, DocumentException {
        // Validate file against the schema
        LineNumberReader lineNumberReader = new LineNumberReader(new FileReader(file));
        Source src = new StreamSource(lineNumberReader);

        logger.finest("Loading RELAX NG Schema");
        SchemaFactory schemaFactory = CompactSyntaxSchemaFactory.newInstance(XMLConstants.RELAXNG_NS_URI);
        Schema schema;

        try {
            schema = schemaFactory.newSchema(CML_SCHEMA);
        } catch (SAXException e) {
            logger.fine("Exception while parsing schema:");
            logger.log(Level.FINE, e.getMessage(), e);
            return null;  // shouldnt happen
        }

        Validator validator = schema.newValidator();

        try {
            logger.finer("Validating file");
            validator.validate(src);
        } catch (SAXException e) {
            throw new CMLParseException("%s:%d: %s".formatted(file, lineNumberReader.getLineNumber(), e.getMessage()));
        }

        lineNumberReader.close();

        // Load document
        logger.finest("Loading file into DOM");
        SAXReader saxReader = new SAXReader();
        Document doc = saxReader.read(file);

        return doc;
    }

    /**
     * Load widgets from a document. This document should have already been
     * validated against CML_SCHEMA.
     * @param doc The document to load widgets from.
     */
    private void loadWidgets(Document doc) {
        List<Node> widgetNodes = doc.selectNodes("/cedarml/widget");
        logger.fine("Found %d widget declarations".formatted(widgetNodes.size()));

        for (Node node : widgetNodes) {
            CMLWidgetSchema schema = new CMLWidgetSchema();
            String widgetName = node.valueOf("@name");

            logger.finer("Widget " + widgetName);

            // Set content type if applicable
            Node contentTypeNode = node.selectSingleNode("@contentType");
            if (contentTypeNode != null) {
                schema.contentType = CedarMLType.fromString(contentTypeNode.getStringValue());
            }

            // Load attrs
            List<Node> attrNodes = node.selectNodes("attr");
            logger.finer("Found %d attributes".formatted(attrNodes.size()));
            for (Node attrNode : attrNodes) {
                AttrSchema attrSchema = new AttrSchema();

                // Set the type of the attr
                // @type guaranteed by schema
                String attrType = attrNode.valueOf("@type");
                attrSchema.type = CedarMLType.fromString(attrType);

                // Set the default value if specified
                Node defaultValueNode = attrNode.selectSingleNode("@default");
                if (defaultValueNode != null) {
                    attrSchema.defaultValue = defaultValueNode.getStringValue();
                }

                // Add the attr to the widget schema
                String attrName = attrNode.valueOf("@name");  // @name guaranteed by schema
                logger.finer("Attribute " + attrName + " with type " + attrType +
                        ((defaultValueNode != null) ? " and default value " + attrSchema.defaultValue : ""));
                schema.attrs.put(
                        attrName,
                        attrSchema
                );
            }

            // Load constructor if specified
            Node ctorNode = node.selectSingleNode("constructor");
            if (ctorNode != null) {
                // Constructor is specified
                schema.ctor.name = ctorNode.valueOf("@name");  // @name guaranteed by schema

                // Get constructor parameters
                List<Node> paramNodes = ctorNode.selectNodes("param");
                for (Node paramNode : paramNodes) {
                    schema.ctor.params.add(paramNode.getText());
                }

                logger.finer("Found constructor %s with %d parameters".formatted(schema.ctor.name, paramNodes.size()));
            }

            // Load initialization if specified
            Node initNode = node.selectSingleNode("init");
            if (initNode != null) {
                // Initialization is specified
                logger.finer("Found initialization block");
                // TODO: this is invalid; need to search children
                if (initNode.getName().equals("set-property")) {
                    SetPropertySchema setPropertySchema = new SetPropertySchema();

                    setPropertySchema.name = initNode.valueOf("@name");  // @name guaranteed by schema
                    setPropertySchema.value = initNode.getText();  // text content guaranteed by schema

                    schema.init.add(setPropertySchema);
                }
            }

            widgetSchemas.put(widgetName, schema);  // @name guaranteed by schema
        }
    }

    public void generateC() throws FileNotFoundException, CMLParseException {
        // Create CodeWriters for output
        CodeWriter header = new CodeWriter(outDir + baseFileName + ".h");
        CodeWriter source = new CodeWriter(outDir + baseFileName + ".c");

        logger.finest("Writing boilerplate code");

        // Write generator ID comments
        header.ln(GENERATOR_COMMENT);
        source.ln(GENERATOR_COMMENT);

        // Write beginning of the header file
        header.ln("""
                #ifndef __CMLC_GENERATED_%s_H_
                #define __CMLC_GENERATED_%s_H_
                
                #ifdef __cplusplus
                extern "C" {
                #endif
                
                #include <stdint.h>
                #include <cedar.h>
                """,
                baseFileName.toUpperCase());

        // Write beginning of the source file
        source.ln("""
                #define __CMLC_GENERATED_%1$s_C_
                #include "%2$s.h"
                """, baseFileName.toUpperCase(), baseFileName);
        source.ln();

        // Declare globals
        logger.fine("Declaring global variables");
        generateGlobals(header, source);
        source.ln();

        // Declare prototypes
        logger.fine("Declaring function prototypes");
        declarePrototypes(header, source);
        source.ln();

        // Generate window functions
        List<Node> windowNodes = cmlDocument.selectNodes("/cedarml/window");
        logger.fine("Found %d window declarations".formatted(windowNodes.size()));
        for (Node windowNode : windowNodes) {
            String winName = windowNode.valueOf("@name");
            String fnName = funcName(winName);  // @name guaranteed by schema
            String handler = windowNode.valueOf("@handler");  // @handler guaranteed by schema

            logger.info("Generating window " + winName);

            // Begin method
            source.ln("void %s() {", fnName);
            source.indent();
            source.ln("""
                    CedarWindow window;
                    cedar_initWindow(&window);
                    
                    cedar_RegisterEventHandler(window.handlers, %s);
                    """, handler);
            source.ln();

            // Apply window colors
            // TODO: rework colour API in libcedar

            // Create menu
            Node menuNode = windowNode.selectSingleNode("menu");
            if (menuNode != null) {
                // Menu is specified
                logger.fine("Generating menu");
                String menuVar = generateMenu(menuNode, source);
                source.ln("cedar_SetMenu(&window, &%s);", menuVar);
                source.ln("");
            }

            // Add timers
            List<Node> timerNodes = windowNode.selectNodes("timer");
            logger.fine("Found %d timers".formatted(timerNodes.size()));
            for (Node timerNode : timerNodes) {
                String timerID = timerNode.valueOf("@id");  // @id guaranteed by schema
                String period = timerNode.valueOf("@period");  // @period guaranteed by schema
                logger.finer("Adding timer " + timerID);
                source.ln("cedar_AddTimer(&window, %s, %s);", timerID, period);
            }

            source.ln();

            // Generate body
            logger.fine("Generating body");
            source.ln("/* Widgets */");
            // node /body guaranteed by schema
            Node bodyNode = windowNode.selectSingleNode("body");
            List<Node> bodyContents = bodyNode.selectNodes("*");
            logger.finer("Found %d widgets".formatted(bodyContents.size()));
            for (Node child : bodyContents) {
                String childTagName = child.getName();

                if (childTagName.equals("var")) {
                    // Declare a variable
                    String ctype = child.valueOf("@ctype");
                    String name = child.valueOf("@name");
                    String defaultVal = child.valueOf("@default");

                    if (defaultVal.equals("")) {
                        logger.finer("Declared variable %s with type %s".formatted(name, ctype));
                        source.ln("%s %s;", ctype, name);
                    } else {
                        logger.finer("Assigned variable %s with type %s to %s".formatted(name, ctype, defaultVal));
                        source.ln("%s %s = %s;", ctype, name, defaultVal);
                    }
                } else {
                    // User defined widget
                    logger.finer("Widget " + childTagName);

                    if (!widgetSchemas.containsKey(childTagName)) {
                        // Widget is not defined
                        throw new CMLParseException("%s: Widget '%s' is undefined".formatted(srcFile, childTagName));
                    }

                    CMLWidgetSchema widgetSchema = widgetSchemas.get(childTagName);
                    Map<String, String> attrs = new HashMap<>();
                    String content = null;

                    // Load content if applicable
                    if (widgetSchema.contentType != null) {
                        if (child.hasContent()) {
                            content = child.getText();
                        } else {
                            throw new CMLParseException("%s: Widget %s requires content".formatted(srcFile, childTagName));
                        }
                    }

                    // Load each attribute
                    for (var entry : widgetSchema.attrs.entrySet()) {
                        Node attrNode = child.selectSingleNode("@" + entry.getKey());

                        if (attrNode != null) {
                            // Node is specified
                            String attrVal = attrNode.getStringValue();

                            // Validate type
                            if (!entry.getValue().type.validate(attrVal)) {
                                throw new CMLParseException("%s: Attribute %s must have type %s".formatted(srcFile, entry.getKey(), entry.getValue().type.toString()));
                            }

                            attrs.put(entry.getKey(), attrVal);
                        } else {
                            // Node is not specified
                            if (entry.getValue().defaultValue != null) {
                                // Add default value to attrs
                                attrs.put(entry.getKey(), entry.getValue().defaultValue);
                            } else {
                                // Attribute is not specified but it must be
                                throw new CMLParseException("%s: Widget %s requires attribute %s".formatted(srcFile, childTagName, entry.getKey()));
                            }
                        }
                    }

                    // Create widget
                    String widget = child.valueOf("@var");

                    String constructor = new Template(widgetSchema.ctor.toString()).toString(content, attrs);

                    if (!widget.equals("")) {
                        // Var name is specified
                        source.ln("%s = %s;", widget, constructor);
                    } else if (widgetSchema.init.size() > 0) {
                        // No var name specified but one is needed
                        widget = IdentifierGenerator.getIdentifier();
                        source.ln("CedarWidget *%s = %s;", widget, constructor);
                    } else {
                        // No var name specified
                        widget = constructor;
                    }

                    // Add widget
                    source.ln("cedar_AddWidget(&window, %s);", widget);
                }

                source.ln();
            }

            // End method
            source.ln("""
                    
                    cedar_Display(&window);
                    cedar_DestroyWindow(&window);
                    """);
            source.outdent();
            source.ln("}");
        }

        // Write end of header file
        header.ln("""
                
                #ifdef __cplusplus
                }
                #endif
                #endif  // __CMLC_GENERATED_%s_H_
                """, baseFileName.toUpperCase());

        header.flush();
        source.flush();

        header.close();
        source.close();
    }

    /**
     * Generate the corresponding function name for a window
     * @param winName The name of the window
     * @return The name of the window function
     */
    private String funcName(String winName) {
        String capitalizedName = winName.substring(0, 1).toUpperCase() + winName.substring(1);
        return "display" + capitalizedName + "Window";
    }

    /**
     * Generate the C code declaring globals. The generated code expects to be
     * outside a method definition.
     * @param inc CodeWriter for the header file
     * @param src CodeWriter for the source file
     */
    private void generateGlobals(CodeWriter inc, CodeWriter src) {
        List<Node> globals = cmlDocument.selectNodes("//globals");

        if (globals.size() == 0) return;  // Don't do anything if there are no globals

        // Don't declare externs in the source file
        inc.ln("#ifndef __CMLC_GENERATED_%s_C_", baseFileName.toUpperCase());

        for (Node global : globals) {
            String name = global.valueOf("@name");  // @name guaranteed by schema

            // Write externs into header
            inc.ln("extern CedarWidget *%s;", name);

            // Write definitions into source
            src.ln("CedarWidget *%s = NULL", name);
        }

        inc.ln("#endif  // __CMLC_GENERATED_%s_C_", baseFileName.toUpperCase());
    }

    /**
     * Generate the necessary function prototypes in the header and source
     * files.
     * @param inc CodeWriter for the header file
     * @param src CodeWriter for the source file
     */
    private void declarePrototypes(CodeWriter inc, CodeWriter src) {
        List<Node> windowNodes = cmlDocument.selectNodes("/cedarml/window");

        for (Node windowNode : windowNodes) {
            String fnName = funcName(windowNode.valueOf("@name"));  // @name guaranteed by schema
            String handler = windowNode.valueOf("@handler");  // @handler guaranteed by schema

            // Declare function in header
            inc.ln("void %s();", fnName);

            // Declare extern handler in source
            src.ln("extern CALLBACKRESULT %s(void *, EVENT, uint24_t);", handler);
        }
    }

    /**
     * Generate a menu
     * @param rootNode The root menu node
     * @param src The source file's CodeWriter
     * @return The name of the menu's variable
     */
    private String generateMenu(Node rootNode, CodeWriter src) {
        String menuVar = IdentifierGenerator.getIdentifier();

        // Init menu
        src.ln("""
                CedarMenu %s;
                cedar_InitMenu(&%s);
                """, menuVar);

        // Add menu items
        List<Node> menuitems = rootNode.selectNodes("menuitem");
        for (Node menuitem : menuitems) {
            String type = menuitem.valueOf("@type");  // @type guaranteed by schema

            switch (type) {
                case "separator": {
                    logger.finest("Adding menu separator");
                    src.ln("cedar_AddMenuSeparator(&%s);", menuVar);
                    break;
                }
                case "item": {
                    // @id and @label guaranteed by schema
                    String id = menuitem.valueOf("@id");
                    String label = menuitem.valueOf("@label");
                    logger.finest("Adding menu item '%s' (%s)".formatted(label, id));
                    src.ln("cedar_AddMenuItem(&%s, %s, \"%s\");", menuVar, id, label);
                    break;
                }
                case "submenu": {
                    // @id, @label, /menu guaranteed by schema
                    String id = menuitem.valueOf("@id");
                    String label = menuitem.valueOf("@label");
                    Node submenu = menuitem.selectSingleNode("menu");

                    logger.finest("Entering submenu '%s' (%s)".formatted(label, id));

                    src.indent();
                    String submenuVar = generateMenu(submenu, src);
                    src.ln("cedar_AddSubmenu(&%s, %s, \"%s\", &%s);",
                            menuVar, id, label, submenuVar);
                    src.outdent();

                    logger.finest("Exiting submenu '%s' (%s)".formatted(label, id));
                    break;
                }
            }
        }

        return menuVar;
    }
}
